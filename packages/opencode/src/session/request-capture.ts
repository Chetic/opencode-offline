/**
 * Module for capturing and storing the last HTTP request sent to LLM backends.
 * This allows users to reproduce server-side errors by running the captured
 * request as a curl command.
 */

interface CapturedRequest {
  sessionID: string
  timestamp: number
  url: string
  method: string
  headers: Record<string, string>
  body: string
}

// In-memory storage of last request per session
const requests = new Map<string, CapturedRequest>()

/**
 * Escape a string for use in a single-quoted shell string.
 * Single quotes in the content are escaped by ending the quote, adding an escaped quote, and resuming.
 */
function shellEscape(str: string): string {
  return str.replace(/'/g, "'\\''")
}

/**
 * Capture an HTTP request for a session.
 */
function capture(request: CapturedRequest): void {
  requests.set(request.sessionID, request)
}

/**
 * Get the last captured request for a session.
 */
function get(sessionID: string): CapturedRequest | undefined {
  return requests.get(sessionID)
}

/**
 * Clear the captured request for a session.
 */
function clear(sessionID: string): void {
  requests.delete(sessionID)
}

interface ToCurlOptions {
  /** Include auth tokens in the output. Default: true */
  includeAuth?: boolean
  /** Use file parameter ($1) instead of inline body. Default: false */
  useFileParameter?: boolean
}

/**
 * Convert a captured request to a curl command string.
 */
function toCurl(request: CapturedRequest, options: ToCurlOptions = {}): string {
  const { includeAuth = true, useFileParameter = false } = options

  const parts: string[] = ["curl"]

  // Add method
  parts.push(`-X ${request.method}`)

  // Add URL (escaped for shell)
  parts.push(`'${shellEscape(request.url)}'`)

  // Add headers
  for (const [key, value] of Object.entries(request.headers)) {
    // Skip auth headers if not including auth
    if (!includeAuth) {
      const lowerKey = key.toLowerCase()
      if (lowerKey === "authorization" || lowerKey === "x-api-key") {
        continue
      }
    }

    // Skip internal headers that shouldn't be in curl
    const lowerKey = key.toLowerCase()
    if (lowerKey === "content-length") {
      continue
    }

    parts.push(`-H '${shellEscape(key)}: ${shellEscape(value)}'`)
  }

  // Add body if present
  if (request.body) {
    if (useFileParameter) {
      parts.push(`-d @"$1"`)
    } else {
      parts.push(`-d '${shellEscape(request.body)}'`)
    }
  }

  // Join with line continuations for readability
  return parts.join(" \\\n  ")
}

/**
 * Get formatted JSON body (pretty-printed).
 */
function getFormattedBody(request: CapturedRequest): string {
  try {
    const parsed = JSON.parse(request.body)
    return JSON.stringify(parsed, null, 2)
  } catch {
    return request.body
  }
}

interface GenerateJsonFilenameOptions {
  slug: string
  parentSlug?: string
  timestamp: number
}

/**
 * Generate JSON filename: {slug}[-from-{parentSlug}]-{timestamp}.json
 */
function generateJsonFilename(options: GenerateJsonFilenameOptions): string {
  const { slug, parentSlug, timestamp } = options
  const parts = [slug]
  if (parentSlug) {
    parts.push(`from-${parentSlug}`)
  }
  parts.push(String(timestamp))
  return parts.join("-") + ".json"
}

/**
 * Generate full shell script with usage info.
 */
function generateScript(curlCommand: string): string {
  return `#!/bin/sh
# Usage: $0 <json-file>
# Generated by opencode /curl command

if [ -z "$1" ]; then
  echo "Usage: $0 <json-file>" >&2
  exit 1
fi

if [ ! -f "$1" ]; then
  echo "Error: File '$1' not found" >&2
  exit 1
fi

${curlCommand}
`
}

export const RequestCapture = {
  capture,
  get,
  clear,
  toCurl,
  getFormattedBody,
  generateJsonFilename,
  generateScript,
}
